{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dmenv: the stupid virtual environment manager for Python \u00b6 What it does \u00b6 dmenv takes care of: Creating virtual environments for you: one virtual environment per project and Python version, thus enforcing some commonly agreed-upon best practices Generating a lock file that contains all the versions of all your dependencies at a given time, so you can have reproducible builds If does it by: reading information about your project in the setup.py file and nothing else using already existing tools such as python3 -m venv and pip As the tag line implies, its implementation is as simple as possible and it contains the bare minimum amount of features. Want to try it? Proceed to installation and usage .","title":"Home"},{"location":"#dmenv_the_stupid_virtual_environment_manager_for_python","text":"","title":"dmenv: the stupid virtual environment manager for Python"},{"location":"#what_it_does","text":"dmenv takes care of: Creating virtual environments for you: one virtual environment per project and Python version, thus enforcing some commonly agreed-upon best practices Generating a lock file that contains all the versions of all your dependencies at a given time, so you can have reproducible builds If does it by: reading information about your project in the setup.py file and nothing else using already existing tools such as python3 -m venv and pip As the tag line implies, its implementation is as simple as possible and it contains the bare minimum amount of features. Want to try it? Proceed to installation and usage .","title":"What it does"},{"location":"advanced_usage/","text":"Advanced Usage \u00b6 Some definitions \u00b6 Let's assume the following setup.py : # setup.py setup( name=\"demo\", version=\"0.6.1\", ... install_requires=[ \"path.py\" ], extras_require={ \"dev\": [ \"pytest\", ] }, ) Since pytest is only used by the tests, and not the rest of the code, path.py is a regular dependency , and pytest is a development dependency . Now let's assume you've run dmenv lock and that the following lock file was produced: # requirements.lock path-py==11.4.0 importlib-metadata==0.5 pytest==3.9.0 py==1.6.0 importlib-metadata and py are dependencies of path.py and pytest respectively, and their version got \"frozen\" in the lock file. To differentiate those dependencies from the rest, we say that pytest and path.py are abstract , and than importlib-metadata and py are concrete . Note that if you publish your code on pypi.org, consumers of your package will only see the abstract , regular dependencies, so be careful with the install_requires section of the setup.py ! How the lock command works \u00b6 The requirements.lock is obtained by parsing the output of pip freeze , and thus is only a reflection of the state of the virtual environment from which pip was run. That means the result of the lock depends of something \"stateful\" that can change independently of the contents of the setup.py . For instance, if you run dmenv lock in a empty virtual environment, every concrete dependency gets frozen to their latest compatible version. On the other hand, if you run dmenv lock from a virtual environment that already contains foo , the foo version won't change (unless something in the setup.py causes it to change). This may seem like an horrible bug but, as we'll see in the next section, it makes it possible to use various interesting workflows when upgrading dependencies. Two features of dmenv make this work: One, both setup.py and requirements.lock can be edited by hand. Two, when the lock file already exists, dmenv lock \"applies\" the result of pip freeze to the existing lock file, and thus can preserve manual changes. Let's see some examples. Upgrade all the things! \u00b6 The simplest way is to just re-run dmenv lock after having cleaned the virtual environment: $ dmenv clean $ dmenv lock That way, all existing dependencies from the requirements.lock will get ignored, and you'll get the latest version of everything listed in the setup.py . Give it a go, it often works better than you might think :) If something breaks (for instance when going from path.py 11.4 to path.py 11.5), you can edit the setup.py to specify that you are not compatible with the latest of path.py: setup( ... install_requires=[ \"path.py < 11.5\", ], ) Freeze dev dependencies \u00b6 The above approach does not work really well if you use a linter like pylint or flake8 , of even a type checker like mypy This is because new releases of those tools often cause new warnings or errors to be produced, so you only want to update them when you're ready. Thus, a good practice is to freeze the versions of those tools directly in the setup.py : setup( extras_require={ \"dev\": [ \"flake8==3.5.0\", ] } ) That way you can freely re-run dmenv lock , even in a completely fresh environment. Upgrading just one development dependency \u00b6 For instance if there's a bug in py , you can bump py version by editing the lock file directly: - py==1.6.0 + py==1.7.0 Upgrading just one regular dependency \u00b6 If the bug is in one of the concrete dependencies, you should update the setup.py file instead install_requires=[ \"path.py\" + \"importlib-metadata >= 0.6\" ] That way consumers of your code will get the correct version. Then run dmenv lock without cleaning the virtual environment so that importlib-metadata gets upgraded and its new version frozen. Using dependencies from git URLs \u00b6 Let's say you came across a bug that's only fixed on the master branch of pytest on GitHub, specifically at the commit deadbeef . One solution is to replace the line in requirements.lock to use a git URL like this: # requirements git+https://github.com/pytest-dev/pytest@deadbeef#egg=pytest In that case, pip freeze will contain a line looking like pytest==4.0b1 , where 4.0b1 is the pytest version at this particular commit. When it comes to re-generating the lock, dmenv will see that there is already a line specifying the pytest version in a more precise manner, so it will keep the git line in the lock and ignore the non-precise 4.0b1 version. Using different system platforms \u00b6 Sometimes a concrete dependency will only be available on a specify platform. So if you've generated the lock file on Linux, you may get different results on Windows. One way to solve this is to run dmenv lock with the --platfrom argument. Existing lines in the lock file will be kept, and any new dependency will be suffixed with a platform marker , like this: # requirements.lock, generated on liux foo==0.2 > dmenv lock --platform windows # run on Windows # requirements.lock foo==0.2 pywin2==0.42 ; platform == \"windows\" Using different Python versions \u00b6 If you want your code to be run across different Python versions, you may encounter similar issues. Sometimes one of your concrete dependency will only be required for old interpreters. For instance, the pathlib2 package is only useful for 3.5 and below. After that you simply use the standard library. In than case, you can specify a python version requirement, like this: # requirements.lock , generated with Python 3.6 foo==0.2 $ dmenv lock --python '< \"3.5\"' <- note the quotes # requirements.lock foo==0.2 bar==0.42 ; python_version < \"3.5\"","title":"Advanced Usage"},{"location":"advanced_usage/#advanced_usage","text":"","title":"Advanced Usage"},{"location":"advanced_usage/#some_definitions","text":"Let's assume the following setup.py : # setup.py setup( name=\"demo\", version=\"0.6.1\", ... install_requires=[ \"path.py\" ], extras_require={ \"dev\": [ \"pytest\", ] }, ) Since pytest is only used by the tests, and not the rest of the code, path.py is a regular dependency , and pytest is a development dependency . Now let's assume you've run dmenv lock and that the following lock file was produced: # requirements.lock path-py==11.4.0 importlib-metadata==0.5 pytest==3.9.0 py==1.6.0 importlib-metadata and py are dependencies of path.py and pytest respectively, and their version got \"frozen\" in the lock file. To differentiate those dependencies from the rest, we say that pytest and path.py are abstract , and than importlib-metadata and py are concrete . Note that if you publish your code on pypi.org, consumers of your package will only see the abstract , regular dependencies, so be careful with the install_requires section of the setup.py !","title":"Some definitions"},{"location":"advanced_usage/#how_the_lock_command_works","text":"The requirements.lock is obtained by parsing the output of pip freeze , and thus is only a reflection of the state of the virtual environment from which pip was run. That means the result of the lock depends of something \"stateful\" that can change independently of the contents of the setup.py . For instance, if you run dmenv lock in a empty virtual environment, every concrete dependency gets frozen to their latest compatible version. On the other hand, if you run dmenv lock from a virtual environment that already contains foo , the foo version won't change (unless something in the setup.py causes it to change). This may seem like an horrible bug but, as we'll see in the next section, it makes it possible to use various interesting workflows when upgrading dependencies. Two features of dmenv make this work: One, both setup.py and requirements.lock can be edited by hand. Two, when the lock file already exists, dmenv lock \"applies\" the result of pip freeze to the existing lock file, and thus can preserve manual changes. Let's see some examples.","title":"How the lock command works"},{"location":"advanced_usage/#upgrade_all_the_things","text":"The simplest way is to just re-run dmenv lock after having cleaned the virtual environment: $ dmenv clean $ dmenv lock That way, all existing dependencies from the requirements.lock will get ignored, and you'll get the latest version of everything listed in the setup.py . Give it a go, it often works better than you might think :) If something breaks (for instance when going from path.py 11.4 to path.py 11.5), you can edit the setup.py to specify that you are not compatible with the latest of path.py: setup( ... install_requires=[ \"path.py < 11.5\", ], )","title":"Upgrade all the things!"},{"location":"advanced_usage/#freeze_dev_dependencies","text":"The above approach does not work really well if you use a linter like pylint or flake8 , of even a type checker like mypy This is because new releases of those tools often cause new warnings or errors to be produced, so you only want to update them when you're ready. Thus, a good practice is to freeze the versions of those tools directly in the setup.py : setup( extras_require={ \"dev\": [ \"flake8==3.5.0\", ] } ) That way you can freely re-run dmenv lock , even in a completely fresh environment.","title":"Freeze dev dependencies"},{"location":"advanced_usage/#upgrading_just_one_development_dependency","text":"For instance if there's a bug in py , you can bump py version by editing the lock file directly: - py==1.6.0 + py==1.7.0","title":"Upgrading just one development dependency"},{"location":"advanced_usage/#upgrading_just_one_regular_dependency","text":"If the bug is in one of the concrete dependencies, you should update the setup.py file instead install_requires=[ \"path.py\" + \"importlib-metadata >= 0.6\" ] That way consumers of your code will get the correct version. Then run dmenv lock without cleaning the virtual environment so that importlib-metadata gets upgraded and its new version frozen.","title":"Upgrading just one regular dependency"},{"location":"advanced_usage/#using_dependencies_from_git_urls","text":"Let's say you came across a bug that's only fixed on the master branch of pytest on GitHub, specifically at the commit deadbeef . One solution is to replace the line in requirements.lock to use a git URL like this: # requirements git+https://github.com/pytest-dev/pytest@deadbeef#egg=pytest In that case, pip freeze will contain a line looking like pytest==4.0b1 , where 4.0b1 is the pytest version at this particular commit. When it comes to re-generating the lock, dmenv will see that there is already a line specifying the pytest version in a more precise manner, so it will keep the git line in the lock and ignore the non-precise 4.0b1 version.","title":"Using dependencies from git URLs"},{"location":"advanced_usage/#using_different_system_platforms","text":"Sometimes a concrete dependency will only be available on a specify platform. So if you've generated the lock file on Linux, you may get different results on Windows. One way to solve this is to run dmenv lock with the --platfrom argument. Existing lines in the lock file will be kept, and any new dependency will be suffixed with a platform marker , like this: # requirements.lock, generated on liux foo==0.2 > dmenv lock --platform windows # run on Windows # requirements.lock foo==0.2 pywin2==0.42 ; platform == \"windows\"","title":"Using different system platforms"},{"location":"advanced_usage/#using_different_python_versions","text":"If you want your code to be run across different Python versions, you may encounter similar issues. Sometimes one of your concrete dependency will only be required for old interpreters. For instance, the pathlib2 package is only useful for 3.5 and below. After that you simply use the standard library. In than case, you can specify a python version requirement, like this: # requirements.lock , generated with Python 3.6 foo==0.2 $ dmenv lock --python '< \"3.5\"' <- note the quotes # requirements.lock foo==0.2 bar==0.42 ; python_version < \"3.5\"","title":"Using different Python versions"},{"location":"basic_usage/","text":"Usage \u00b6 Setup \u00b6 First, dmenv needs a Python3 interpreter in PATH, which should be called python or python3 . This should already be the case if you've just installed Python3, regardless of your operating system. Second, dmenv needs a setup.py file to work. If you don't have a setup.py yet, you can run dmenv init <project name> to generate one. In this case, make sure to read the comments inside and edit it to fit your needs. If you already have one, please note that dmenv uses the extras_require keyword with a dev key to specify development dependencies, which you can use to replace your dev-requirements.txt file for instance. In both cases, here are the contents of setup.py file you should end up with: from setuptools import setup setup( name=\"demo\", version=\"0.6.1\", ... install_requires=[ \"path.py\", ], extras_require={ \"dev\": [ \"pytest\", ], }, ... ) You are now ready to use dmenv . Keep on reading about the two main commands: dmenv lock and dmenv install . dmenv lock \u00b6 Here's what dmenv lock does: It looks for a binary named python3 or python in the PATH environment variable. It runs a bit of Python code to determine the interpreter version (3.6, 3.7 ...). Then, it creates a virtual environment in .venv/<version> using python -m venv . (This step is skipped if dmenv detects it is run from an existing virtual environment). Note that you may have to configure other tools to ignore this directory. Then it runs pip intall --editable .[dev] so that your dev dependencies are installed, and the scripts listed in entry_points are created. Finally, it runs pip freeze to generate a requirements.lock file. Now you can add the requirements.lock file to your version control system. This leads us to the next command: dmenv install \u00b6 Now that the complete list of dependencies and their versions is written in the requirements.lock file, anyone can run dmenv install to install all the dependencies and get exactly the same versions you got when you ran dmenv lock . Hooray reproducible builds! Configuring other tools \u00b6 Depending of your usage, you may need to tell other tools to ignore the .venv directory. git : add a line containing .venv/ to the .gitgnore . # should be already there if you use # setup.py *.egg-info build/ dist/ # only directory in which `dmenv` will write files: .venv/ pyflakes , pylint and other linters: add some configuration in the setup.cfg file: exclude = .venv As an alternative, you can also ask dmenv to create its virtual environment outside your project, by setting the DMENV_VENV_OUTSIDE_PROJECT environment variable to a non-empty value like 1 . It will then use the app_dirs crate as a location to store the created virtual environments. Going further \u00b6 That's all for the basic usage of dmenv , you may proceed to the goodies section or read on about advanced dmenv usage","title":"Basic Usage"},{"location":"basic_usage/#usage","text":"","title":"Usage"},{"location":"basic_usage/#setup","text":"First, dmenv needs a Python3 interpreter in PATH, which should be called python or python3 . This should already be the case if you've just installed Python3, regardless of your operating system. Second, dmenv needs a setup.py file to work. If you don't have a setup.py yet, you can run dmenv init <project name> to generate one. In this case, make sure to read the comments inside and edit it to fit your needs. If you already have one, please note that dmenv uses the extras_require keyword with a dev key to specify development dependencies, which you can use to replace your dev-requirements.txt file for instance. In both cases, here are the contents of setup.py file you should end up with: from setuptools import setup setup( name=\"demo\", version=\"0.6.1\", ... install_requires=[ \"path.py\", ], extras_require={ \"dev\": [ \"pytest\", ], }, ... ) You are now ready to use dmenv . Keep on reading about the two main commands: dmenv lock and dmenv install .","title":"Setup"},{"location":"basic_usage/#dmenv_lock","text":"Here's what dmenv lock does: It looks for a binary named python3 or python in the PATH environment variable. It runs a bit of Python code to determine the interpreter version (3.6, 3.7 ...). Then, it creates a virtual environment in .venv/<version> using python -m venv . (This step is skipped if dmenv detects it is run from an existing virtual environment). Note that you may have to configure other tools to ignore this directory. Then it runs pip intall --editable .[dev] so that your dev dependencies are installed, and the scripts listed in entry_points are created. Finally, it runs pip freeze to generate a requirements.lock file. Now you can add the requirements.lock file to your version control system. This leads us to the next command:","title":"dmenv lock"},{"location":"basic_usage/#dmenv_install","text":"Now that the complete list of dependencies and their versions is written in the requirements.lock file, anyone can run dmenv install to install all the dependencies and get exactly the same versions you got when you ran dmenv lock . Hooray reproducible builds!","title":"dmenv install"},{"location":"basic_usage/#configuring_other_tools","text":"Depending of your usage, you may need to tell other tools to ignore the .venv directory. git : add a line containing .venv/ to the .gitgnore . # should be already there if you use # setup.py *.egg-info build/ dist/ # only directory in which `dmenv` will write files: .venv/ pyflakes , pylint and other linters: add some configuration in the setup.cfg file: exclude = .venv As an alternative, you can also ask dmenv to create its virtual environment outside your project, by setting the DMENV_VENV_OUTSIDE_PROJECT environment variable to a non-empty value like 1 . It will then use the app_dirs crate as a location to store the created virtual environments.","title":"Configuring other tools"},{"location":"basic_usage/#going_further","text":"That's all for the basic usage of dmenv , you may proceed to the goodies section or read on about advanced dmenv usage","title":"Going further"},{"location":"changelog/","text":"0.11.0 \u00b6 Add dmenv show:bin_path to show the path of the virtual environment binaries. Breaking changes \u00b6 Fix #31 : make sure the wheel package gets frozen when running dmenv lock . Note: this also causes other packages like setuptools and pip itself to get frozen. As a consequence dmenv install no longer upgrades pip automatically, and so the --no-upgrade-pip option is gone. 0.10.0 \u00b6 Allow using dmenv outside the current project, by setting an environment variable named DMENV_VENV_OUTSIDE_PROJECT . 0.9.0 \u00b6 Fix #54 : rename --cwd option to --project . Avoid blindly overwriting the requirements.lock file when running. dmenv lock . See #11 and #7 for background. 0.8.4 \u00b6 Fix #49 : return code was always 0 when using dmenv run on Windows. (regression introduced in 0.8.1 ). 0.8.3 \u00b6 Add documentation link to Cargo.toml . 0.8.2 \u00b6 Fix #45 : dmenv env can be used with non-ASCII chars on Windows. 0.8.1 \u00b6 dmenv run now uses execv from libc . This means the child process is killed when killing dmenv . The previous behavior (starting a new subprocess) can be activated with the --no-exec option. 0.8.0 \u00b6 Allow using python3 -m virtualenv instead of python3 -m venv to create the virtual environments by setting an environment variable named DMENV_NO_VENV_STDLIB . This can be used to work around some bugs in Debian-based distributions. 0.7.0 \u00b6 Add bump-in-lock command. Use to bump version or git references in the requirements.lock file. 0.6.0 \u00b6 Run setup.py develop with --no-deps . Rename show to show:venv_path , add show:deps to display the list of dependencies. 0.5.0 \u00b6 dmenv init : since name is required, it is now an argument, no longer an option. So instead of dmenv init --name foo --version 0.42 , use dmenv init foo --version 0.42 Add a command named dmenv develop that just runs python setup.py develop and nothing else. dmenv install : add --no-upgrade-pip and --no-develop options. 0.4.3 \u00b6 Add a --author option to dmenv init , used when generating the setup.py file. Fix #12 : dmenv lock now exits immediately if the lock file is missing. Workaround Debian bug in pip (See #15 for details). 0.4.2 \u00b6 Write some metadata inside the requirements.lock file. Improve dmenv run : Suggest running lock or install Do not crash if used without arguments 0.4.1 \u00b6 Fix CI on Windows. 0.4.0 \u00b6 dmenv no longer needs a configuration file. Find the Python interpreter to use by looking in the PATH environment variable. 0.3.4 \u00b6 Fix #9 : If dmenv is run inside an existing virtual environment , just use it. 0.3.3 \u00b6 Also upgrade pip when running dmenv install . Fix incorrect message when running dmenv lock . 0.3.2 \u00b6 Fix regression introduced in 0.3.1: create config path parent subdirectory before trying to write inside it. 0.3.1 \u00b6 Add a dmenv subdirectory to the configuration file path. 0.3.0 \u00b6 Replace command freeze by lock . 0.2.3 \u00b6 Add command dmenv init to generate a working setup.py file. 0.2.2 \u00b6 Fix running dmenv on Windows. The configuration file is now read from $HOME ( ~/.config on Linux and macOS, %HOME%\\AppData\\Local on Windows). 0.2.1 \u00b6 The .dmenv.toml file is now required. 0.2.0 \u00b6 Can be used with multiple python versions, using the .dmenv.toml config file. 0.1.0 \u00b6 Initial release.","title":"Changelog"},{"location":"changelog/#0110","text":"Add dmenv show:bin_path to show the path of the virtual environment binaries.","title":"0.11.0"},{"location":"changelog/#breaking_changes","text":"Fix #31 : make sure the wheel package gets frozen when running dmenv lock . Note: this also causes other packages like setuptools and pip itself to get frozen. As a consequence dmenv install no longer upgrades pip automatically, and so the --no-upgrade-pip option is gone.","title":"Breaking changes"},{"location":"changelog/#0100","text":"Allow using dmenv outside the current project, by setting an environment variable named DMENV_VENV_OUTSIDE_PROJECT .","title":"0.10.0"},{"location":"changelog/#090","text":"Fix #54 : rename --cwd option to --project . Avoid blindly overwriting the requirements.lock file when running. dmenv lock . See #11 and #7 for background.","title":"0.9.0"},{"location":"changelog/#084","text":"Fix #49 : return code was always 0 when using dmenv run on Windows. (regression introduced in 0.8.1 ).","title":"0.8.4"},{"location":"changelog/#083","text":"Add documentation link to Cargo.toml .","title":"0.8.3"},{"location":"changelog/#082","text":"Fix #45 : dmenv env can be used with non-ASCII chars on Windows.","title":"0.8.2"},{"location":"changelog/#081","text":"dmenv run now uses execv from libc . This means the child process is killed when killing dmenv . The previous behavior (starting a new subprocess) can be activated with the --no-exec option.","title":"0.8.1"},{"location":"changelog/#080","text":"Allow using python3 -m virtualenv instead of python3 -m venv to create the virtual environments by setting an environment variable named DMENV_NO_VENV_STDLIB . This can be used to work around some bugs in Debian-based distributions.","title":"0.8.0"},{"location":"changelog/#070","text":"Add bump-in-lock command. Use to bump version or git references in the requirements.lock file.","title":"0.7.0"},{"location":"changelog/#060","text":"Run setup.py develop with --no-deps . Rename show to show:venv_path , add show:deps to display the list of dependencies.","title":"0.6.0"},{"location":"changelog/#050","text":"dmenv init : since name is required, it is now an argument, no longer an option. So instead of dmenv init --name foo --version 0.42 , use dmenv init foo --version 0.42 Add a command named dmenv develop that just runs python setup.py develop and nothing else. dmenv install : add --no-upgrade-pip and --no-develop options.","title":"0.5.0"},{"location":"changelog/#043","text":"Add a --author option to dmenv init , used when generating the setup.py file. Fix #12 : dmenv lock now exits immediately if the lock file is missing. Workaround Debian bug in pip (See #15 for details).","title":"0.4.3"},{"location":"changelog/#042","text":"Write some metadata inside the requirements.lock file. Improve dmenv run : Suggest running lock or install Do not crash if used without arguments","title":"0.4.2"},{"location":"changelog/#041","text":"Fix CI on Windows.","title":"0.4.1"},{"location":"changelog/#040","text":"dmenv no longer needs a configuration file. Find the Python interpreter to use by looking in the PATH environment variable.","title":"0.4.0"},{"location":"changelog/#034","text":"Fix #9 : If dmenv is run inside an existing virtual environment , just use it.","title":"0.3.4"},{"location":"changelog/#033","text":"Also upgrade pip when running dmenv install . Fix incorrect message when running dmenv lock .","title":"0.3.3"},{"location":"changelog/#032","text":"Fix regression introduced in 0.3.1: create config path parent subdirectory before trying to write inside it.","title":"0.3.2"},{"location":"changelog/#031","text":"Add a dmenv subdirectory to the configuration file path.","title":"0.3.1"},{"location":"changelog/#030","text":"Replace command freeze by lock .","title":"0.3.0"},{"location":"changelog/#023","text":"Add command dmenv init to generate a working setup.py file.","title":"0.2.3"},{"location":"changelog/#022","text":"Fix running dmenv on Windows. The configuration file is now read from $HOME ( ~/.config on Linux and macOS, %HOME%\\AppData\\Local on Windows).","title":"0.2.2"},{"location":"changelog/#021","text":"The .dmenv.toml file is now required.","title":"0.2.1"},{"location":"changelog/#020","text":"Can be used with multiple python versions, using the .dmenv.toml config file.","title":"0.2.0"},{"location":"changelog/#010","text":"Initial release.","title":"0.1.0"},{"location":"faq/","text":"FAQ \u00b6 I'm on Debian, and I've got errors when running bdist_wheel \u00b6 This is an upstream bug . As a workaround, you can install virtual environment with python3 -m pip install virtual environment --user and then set the DMENV_NO_VENV_STDLIB environment variable to a non-empty value like 1 . Why Rust? \u00b6 Because it has excellent support for what we need: manipulate paths and run commands in a cross-platform way Because it's my second favorite language Because distribution is really easy Because by not using Python at all dmenv is less likely to break if something on your system changes.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#im_on_debian_and_ive_got_errors_when_running_bdist_wheel","text":"This is an upstream bug . As a workaround, you can install virtual environment with python3 -m pip install virtual environment --user and then set the DMENV_NO_VENV_STDLIB environment variable to a non-empty value like 1 .","title":"I'm on Debian, and I've got errors when running bdist_wheel"},{"location":"faq/#why_rust","text":"Because it has excellent support for what we need: manipulate paths and run commands in a cross-platform way Because it's my second favorite language Because distribution is really easy Because by not using Python at all dmenv is less likely to break if something on your system changes.","title":"Why Rust?"},{"location":"goodies/","text":"dmenv goodies \u00b6 dmenv also comes with a few commands for carrying out boring tasks. You can view the full list by running dmenv help , here are a few more details: dmenv run \u00b6 You can use: dmenv run to run any binary from the virtual environment. If the program you want to run needs command-line options, use a -- separator, like so: dmenv run -- pytest --collect-only dmenv upgrade-pip \u00b6 Tired of pip telling you to upgrade itself? Run dmenv upgrade-pip :) It's exactly the same as typing dmenv run -- python -m pip install --upgrade pip , but with less keystrokes :P dmenv show:venv_path \u00b6 dmenv show:venv_path shows the path of the current virtual environment. Nothing more, nothing less. dmenv show:bin_path \u00b6 dmenv show:bin_path shows the path of the virtual environment's binaries. You can use it in CI scripts like this: script: - dmenv install - export PATH=$(dmenv show:bin_path):$PATH dmenv show:deps \u00b6 Just a wrapper for pip list : $ dmenv show:deps Package Version ------------------ ------- atomicwrites 1.2.1 attrs 18.2.0 importlib-metadata 0.6 ... dmenv bump-in-lock \u00b6 You can use bump-in-lock to bump versions directly in the requirements.lock file: # contents of requirements.lock: bar==0.3 foo==1.2 $ dmenv bump-in-lock bar 0.4 # new contents: bar==0.4 foo==1.2 If you used a git URL in the requirements.lock file, you can also bump the git reference: # contents of requirements.lock: bar==0.3 foo==git@gitlab.com/foo/foo@master#egg=foo $ dmenv bump-in-lock --git foo deadbeef bar==0.3 foo==git@gitlab.com/foo/foo@deadbeef#egg=foo","title":"Goodies"},{"location":"goodies/#dmenv_goodies","text":"dmenv also comes with a few commands for carrying out boring tasks. You can view the full list by running dmenv help , here are a few more details:","title":"dmenv goodies"},{"location":"goodies/#dmenv_run","text":"You can use: dmenv run to run any binary from the virtual environment. If the program you want to run needs command-line options, use a -- separator, like so: dmenv run -- pytest --collect-only","title":"dmenv run"},{"location":"goodies/#dmenv_upgrade-pip","text":"Tired of pip telling you to upgrade itself? Run dmenv upgrade-pip :) It's exactly the same as typing dmenv run -- python -m pip install --upgrade pip , but with less keystrokes :P","title":"dmenv upgrade-pip"},{"location":"goodies/#dmenv_showvenv_path","text":"dmenv show:venv_path shows the path of the current virtual environment. Nothing more, nothing less.","title":"dmenv show:venv_path"},{"location":"goodies/#dmenv_showbin_path","text":"dmenv show:bin_path shows the path of the virtual environment's binaries. You can use it in CI scripts like this: script: - dmenv install - export PATH=$(dmenv show:bin_path):$PATH","title":"dmenv show:bin_path"},{"location":"goodies/#dmenv_showdeps","text":"Just a wrapper for pip list : $ dmenv show:deps Package Version ------------------ ------- atomicwrites 1.2.1 attrs 18.2.0 importlib-metadata 0.6 ...","title":"dmenv show:deps"},{"location":"goodies/#dmenv_bump-in-lock","text":"You can use bump-in-lock to bump versions directly in the requirements.lock file: # contents of requirements.lock: bar==0.3 foo==1.2 $ dmenv bump-in-lock bar 0.4 # new contents: bar==0.4 foo==1.2 If you used a git URL in the requirements.lock file, you can also bump the git reference: # contents of requirements.lock: bar==0.3 foo==git@gitlab.com/foo/foo@master#egg=foo $ dmenv bump-in-lock --git foo deadbeef bar==0.3 foo==git@gitlab.com/foo/foo@deadbeef#egg=foo","title":"dmenv bump-in-lock"},{"location":"installation/","text":"Installing dmenv \u00b6 Using the pre-compiled binaries \u00b6 The easiest way is to download the matching binary from the releases page for your platform and put it somewhere on in your $PATH. Linux, macOS \u00b6 cd ~/.local/bin curl --fail -L \\ https://github.com/TankerHQ/dmenv/releases/download/v0.10.0/dmenv-<platform> \\ -o dmenv chmod u+x dmenv Notes: Replace <platform> by your current platform: linux , or osx in the above command line. Make sure ~/.local/bin is in your PATH. Windows \u00b6 Download the dmenv-windows.exe from the release page and save it for instance in c:\\path\\to\\python\\Scripts\\dmenv.exe . (This directory should already be in you PATH if you used the default settings when installing Python). Installing from source \u00b6 If you prefer, you can also install rust and install dmenv with cargo install dmenv .","title":"Installation"},{"location":"installation/#installing_dmenv","text":"","title":"Installing dmenv"},{"location":"installation/#using_the_pre-compiled_binaries","text":"The easiest way is to download the matching binary from the releases page for your platform and put it somewhere on in your $PATH.","title":"Using the pre-compiled binaries"},{"location":"installation/#linux_macos","text":"cd ~/.local/bin curl --fail -L \\ https://github.com/TankerHQ/dmenv/releases/download/v0.10.0/dmenv-<platform> \\ -o dmenv chmod u+x dmenv Notes: Replace <platform> by your current platform: linux , or osx in the above command line. Make sure ~/.local/bin is in your PATH.","title":"Linux, macOS"},{"location":"installation/#windows","text":"Download the dmenv-windows.exe from the release page and save it for instance in c:\\path\\to\\python\\Scripts\\dmenv.exe . (This directory should already be in you PATH if you used the default settings when installing Python).","title":"Windows"},{"location":"installation/#installing_from_source","text":"If you prefer, you can also install rust and install dmenv with cargo install dmenv .","title":"Installing from source"}]}